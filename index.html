
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brain Hacker</title>
  <style>
    body { margin: 0; padding: 10px; font-family: sans-serif; }
    .controls { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px; }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      grid-template-rows: repeat(16, 1fr);
      width: 100vw;
      height: 80vh;
      gap: 1px;
      border: 1px solid #ccc;
    }
    .cell {
      border: 1px solid #aaa;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1px;
      font-size: 1vw;
    }
    .cell.selected { outline: 2px solid #4285f4; }
    .editable {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      flex-direction: column;
      font-size: 1vw;
      text-align: left;
      padding: 2px;
      border: none;
      outline: none;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }
  </style>
</head>
<body>
  <div class="controls">
    <button id="insertCheckboxBtn">‚úÖ check</button>
    <button id="insertBoldCheckboxBtn">‚òëÔ∏è check</button>
    <button id="uploadImageBtn">üñºÔ∏è</button>
    <button id="alignLeftBtn">left</button>
    <button id="alignCenterBtn">center</button>
    <button id="deleteBtn">üóëÔ∏è delete</button>
    <button id="undoBtn">‚Ü©Ô∏è Undo</button>
    <button id="redoBtn">‚Ü™Ô∏è Redo</button>
    <button id="resetBtn">üîÑ Reset</button>
    <input type="file" id="imageInput" accept="image/*" style="display: none;" />
  </div>
  <div class="grid-container" id="grid"></div>
  <script>
    const grid = document.getElementById("grid");
    const cells = [];
    const selectedCells = new Set();

    function getCell(row, col) {
      return cells.find(c => c.row === row && c.col === col);
    }

    function createGrid() {
      for (let row = 0; row < 16; row++) {
        for (let col = 0; col < 20; col++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = row;
          cell.dataset.col = col;

          const editable = document.createElement("div");
          editable.classList.add("editable");
          editable.contentEditable = true;

          cell.appendChild(editable);
          grid.appendChild(cell);
          cells.push({ row, col, element: cell });
        }
      }
    }

    function applyToSelectedCells(callback) {
      selectedCells.forEach(key => {
        const [row, col] = key.split(',').map(Number);
        const cell = getCell(row, col)?.element;
        if (cell) callback(cell);
      });
    }

    function createLabeledCheckbox(bold = false) {
      const wrapper = document.createElement("span");
      wrapper.style.display = "inline-flex";
      wrapper.style.alignItems = "center";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.style.marginRight = "4px";
      const span = document.createElement("span");
      span.textContent = "È†ÖÁõÆ";
      span.contentEditable = true;
      span.style.outline = "none";
      if (bold) span.style.fontWeight = "bold";
      wrapper.appendChild(checkbox);
      wrapper.appendChild(span);
      checkbox.addEventListener("change", () => {
        span.style.textDecoration = checkbox.checked ? "line-through" : "none";
      });
      return wrapper;
    }

    document.getElementById("insertCheckboxBtn").addEventListener("click", () => {
      applyToSelectedCells(cell => {
        const editable = cell.querySelector(".editable");
        if (editable) editable.prepend(createLabeledCheckbox(false));
      });
    });

    document.getElementById("insertBoldCheckboxBtn").addEventListener("click", () => {
      applyToSelectedCells(cell => {
        const editable = cell.querySelector(".editable");
        if (editable) editable.prepend(createLabeledCheckbox(true));
      });
    });

    document.addEventListener("click", e => {
      const cell = e.target.closest(".cell");
      if (!cell) return;
      const key = `${cell.dataset.row},${cell.dataset.col}`;
      if (e.ctrlKey || e.metaKey) {
        if (selectedCells.has(key)) {
          selectedCells.delete(key);
          cell.classList.remove("selected");
        } else {
          selectedCells.add(key);
          cell.classList.add("selected");
        }
      } else {
        selectedCells.clear();
        document.querySelectorAll(".cell").forEach(c => c.classList.remove("selected"));
        selectedCells.add(key);
        cell.classList.add("selected");
      }
    });

    
    document.getElementById("uploadImageBtn").addEventListener("click", () => {
      if (selectedCells.size !== 1) {
        alert("ÁîªÂÉè„ÅØ1„Å§„ÅÆ„Çª„É´„Å´„Å†„ÅëÊ∑ª‰ªò„Åß„Åç„Åæ„Åô„ÄÇ1„Çª„É´„ÅÆ„ÅøÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
        return;
      }
      document.getElementById("imageInput").click();
    });

    document.getElementById("imageInput").addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const [row, col] = [...selectedCells][0].split(',').map(Number);
        const cell = getCell(row, col).element;
        let img = cell.querySelector("img");
        if (!img) {
          img = document.createElement("img");
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = "contain";
          cell.appendChild(img);
        }
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
      event.target.value = "";
    });


    
    document.getElementById("alignLeftBtn").addEventListener("click", () => {
      applyToSelectedCells(cell => {
        const editable = cell.querySelector(".editable");
        if (editable) {
          editable.style.alignItems = "flex-start";
          editable.style.justifyContent = "center";
          editable.style.textAlign = "left";
        }
      });
    });

    document.getElementById("alignCenterBtn").addEventListener("click", () => {
      applyToSelectedCells(cell => {
        const editable = cell.querySelector(".editable");
        if (editable) {
          editable.style.alignItems = "center";
          editable.style.justifyContent = "center";
          editable.style.textAlign = "center";
        }
      });
    });


    
    document.getElementById("deleteBtn").addEventListener("click", () => {
      applyToSelectedCells(cell => {
        const editable = cell.querySelector(".editable");
        if (editable) editable.innerHTML = "";
        const img = cell.querySelector("img");
        if (img) img.remove();
      });
    });


    
    let history = [];
    let historyIndex = -1;

    function saveHistory() {
      const snapshot = grid.innerHTML;
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(snapshot);
      historyIndex++;
    }

    function restoreHistory(index) {
      if (index >= 0 && index < history.length) {
        grid.innerHTML = history[index];
        historyIndex = index;
      }
    }

    document.getElementById("undoBtn").addEventListener("click", () => {
      if (historyIndex > 0) restoreHistory(historyIndex - 1);
    });

    document.getElementById("redoBtn").addEventListener("click", () => {
      if (historyIndex < history.length - 1) restoreHistory(historyIndex + 1);
    });

    const observer = new MutationObserver(() => {
      saveHistory();
    });

    observer.observe(grid, { childList: true, subtree: true });


    
    document.getElementById("resetBtn").addEventListener("click", () => {
      if (confirm("Êú¨ÂΩì„Å´„Åô„Åπ„Å¶„ÅÆ„Çª„É´„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü")) {
        grid.innerHTML = "";
        cells.length = 0;
        selectedCells.clear();
        createGrid();
        history = [];
        historyIndex = -1;
      }
    });


    
    function saveState() {
      const state = cells.map(({ row, col, element }) => {
        const editable = element.querySelector(".editable");
        const img = element.querySelector("img");
        return {
          row, col,
          html: editable.innerHTML,
          fontSize: editable.style.fontSize,
          bgColor: element.style.backgroundColor,
          alignItems: editable.style.alignItems,
          justifyContent: editable.style.justifyContent,
          textAlign: editable.style.textAlign,
          imgSrc: img?.src || "",
          gridRow: element.style.gridRow,
          gridColumn: element.style.gridColumn,
          display: element.style.display
        };
      });
      localStorage.setItem("gridState", JSON.stringify(state));
    }

    function loadState() {
      const stateJSON = localStorage.getItem("gridState");
      if (!stateJSON) return;
      const state = JSON.parse(stateJSON);
      state.forEach(data => {
        const cell = getCell(data.row, data.col).element;
        const editable = cell.querySelector(".editable");
        editable.innerHTML = data.html || "";
        editable.style.fontSize = data.fontSize || "";
        editable.style.alignItems = data.alignItems || "flex-start";
        editable.style.justifyContent = data.justifyContent || "flex-start";
        editable.style.textAlign = data.textAlign || "left";
        cell.style.backgroundColor = data.bgColor || "";
        if (data.imgSrc) {
          let img = cell.querySelector("img");
          if (!img) {
            img = document.createElement("img");
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "contain";
            cell.appendChild(img);
          }
          img.src = data.imgSrc;
        cell.style.gridRow = data.gridRow || "";
        cell.style.gridColumn = data.gridColumn || "";
        cell.style.display = data.display || "flex";
        }
      });
    }

    window.addEventListener("beforeunload", () => {
      saveState();
    });


    window.addEventListener("load", () => {
  loadState();
      createGrid();
    });
  </script>
</body>
</html>
